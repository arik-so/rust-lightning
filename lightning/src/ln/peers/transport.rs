/// Abstraction for the transport layer as described by Bolt #8 [https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md]

use bitcoin::secp256k1::{SecretKey, PublicKey};

use ln::peers::conduit::Conduit;
use ln::peers::handler::{ITransport, PeerHandleError, MessageQueuer};
use ln::peers::handshake::{CompletedHandshakeInfo, PeerHandshake};
use ln::{wire, msgs};
use ln::wire::{Encode, Message};

use util::ser::{Writeable, VecWriter};
use util::logger::Logger;
use std::ops::Deref;

/// Interface used by Transport to interact with a handshake object
pub trait IPeerHandshake {
	/// Instantiate a new outbound handshake
	fn new_outbound(initiator_static_private_key: &SecretKey, responder_static_public_key: &PublicKey, initiator_ephemeral_private_key: &SecretKey) -> Self;

	/// Set up the handshake receiving any bytes that need to be sent to the peer
	fn set_up_outbound(&mut self) -> Vec<u8>;

	/// Instantiate a new inbound handshake
	fn new_inbound(responder_static_private_key: &SecretKey, responder_ephemeral_private_key: &SecretKey) -> Self;

	/// Progress the handshake given bytes received from the peer. Returns Some(Conduit, PublicKey) when the handshake
	/// is complete.
	fn process_act(&mut self, input: &[u8]) -> Result<(Option<Vec<u8>>, Option<CompletedHandshakeInfo>), String>;
}

/// Trait representing a container that allows enqueuing of Vec<[u8]>
pub(super) trait PayloadQueuer {
	/// Enqueue item to the queue
	fn push_back(&mut self, item: Vec<u8>);

	/// Returns true if the queue is empty
	fn is_empty(&self) -> bool;

	/// Returns the amount of available space in queue
	fn queue_space(&self) -> usize;
}

pub(super) struct Transport<PeerHandshakeImpl: IPeerHandshake=PeerHandshake> {
	pub(super) conduit: Option<Conduit>,
	handshake: PeerHandshakeImpl,
	their_node_id: Option<PublicKey>,
}

impl<PeerHandshakeImpl: IPeerHandshake> ITransport for Transport<PeerHandshakeImpl> {
	fn new_outbound(initiator_static_private_key: &SecretKey, responder_static_public_key: &PublicKey, initiator_ephemeral_private_key: &SecretKey) -> Self {
		Self {
			conduit: None,
			handshake: PeerHandshakeImpl::new_outbound(initiator_static_private_key, responder_static_public_key, initiator_ephemeral_private_key),
			their_node_id: None,
		}
	}

	fn set_up_outbound(&mut self) -> Vec<u8> {
		self.handshake.set_up_outbound().to_vec()
	}

	fn new_inbound(responder_static_private_key: &SecretKey, responder_ephemeral_private_key: &SecretKey) -> Self {
		Self {
			conduit: None,
			handshake: PeerHandshakeImpl::new_inbound(responder_static_private_key, responder_ephemeral_private_key),
			their_node_id: None,
		}
	}

	fn process_input(&mut self, input: &[u8], output_buffer: &mut impl PayloadQueuer) -> Result<bool, String> {
		match self.conduit {
			// Continue handshake
			None => {
				let (response_option, completed_handshake_info_option) = self.handshake.process_act(input)?;

				// Any response generated by the handshake sequence is put into the response buffer
				if let Some(response) = response_option {
					output_buffer.push_back(response.to_vec());
				}

				// If handshake is complete change the state
				if let Some(completed_handshake_info) = completed_handshake_info_option {
					self.conduit = Some(completed_handshake_info.conduit);
					self.their_node_id = Some(completed_handshake_info.their_node_id);
					Ok(true) // newly connected
				} else {
					Ok(false) // newly connected
				}
			}
			Some(ref mut conduit) => {
				conduit.decryptor.read(input)?;
				Ok(false) // newly connected
			}
		}
	}

	fn drain_messages<L: Deref>(&mut self, logger: L) -> Result<Vec<Message>, PeerHandleError>
		where L::Target: Logger {

		let mut received_messages = vec![];

		match self.conduit {
			None => {}
			Some(ref mut conduit) => {
				for msg_data in &mut conduit.decryptor {
					let mut reader = ::std::io::Cursor::new(&msg_data[..]);
					let message_result = wire::read(&mut reader);
					let message = match message_result {
						Ok(x) => x,
						Err(e) => {
							match e {
								msgs::DecodeError::UnknownVersion => return Err(PeerHandleError { no_connection_possible: false }),
								msgs::DecodeError::UnknownRequiredFeature => {
									log_debug!(logger, "Got a channel/node announcement with an known required feature flag, you may want to update!");
									continue;
								}
								msgs::DecodeError::InvalidValue => {
									log_debug!(logger, "Got an invalid value while deserializing message");
									return Err(PeerHandleError { no_connection_possible: false });
								}
								msgs::DecodeError::ShortRead => {
									log_debug!(logger, "Deserialization failed due to shortness of message");
									return Err(PeerHandleError { no_connection_possible: false });
								}
								msgs::DecodeError::BadLengthDescriptor => return Err(PeerHandleError { no_connection_possible: false }),
								msgs::DecodeError::Io(_) => return Err(PeerHandleError { no_connection_possible: false }),
							}
						}
					};

					received_messages.push(message);
				}
			}
		}

		Ok(received_messages)
	}

	fn is_connected(&self) -> bool {
		self.conduit.is_some()
	}

	fn get_their_node_id(&self) -> PublicKey {
		assert!(self.is_connected(), "Retrieving the remote node_id is only supported after transport is connected");
		self.their_node_id.unwrap()
	}
}

impl<PeerHandshakeImpl: IPeerHandshake> MessageQueuer for Transport<PeerHandshakeImpl> {
	fn enqueue_message<M: Encode + Writeable, Q: PayloadQueuer, L: Deref>(&mut self, message: &M, output_buffer: &mut Q, logger: L)
		where L::Target: Logger {

		match self.conduit {
			None => panic!("Enqueueing messages only supported after transport is connected"),
			Some(ref mut conduit) => {
				log_trace!(logger, "Enqueueing message of type {} to {}", message.type_id(), log_pubkey!(self.their_node_id.unwrap()));

				let mut buffer = VecWriter(Vec::new());
				wire::write(message, &mut buffer).unwrap();
				output_buffer.push_back(conduit.encryptor.encrypt(&buffer.0));
			}
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use ln::peers::test_util::*;

	use bitcoin::secp256k1;
	use bitcoin::secp256k1::key::{PublicKey, SecretKey};
	use ln::msgs;
	use util::test_utils::TestLogger;

	fn create_outbound_for_test<PeerHandshakeImpl: IPeerHandshake>() -> Transport<PeerHandshakeImpl> {
		let curve = secp256k1::Secp256k1::new();
		let outbound_static_private_key = SecretKey::from_slice(&[0x_11_u8; 32]).unwrap();
		let outbound_ephemeral_private_key = SecretKey::from_slice(&[0x_12_u8; 32]).unwrap();
		let inbound_static_private_key = SecretKey::from_slice(&[0x_21_u8; 32]).unwrap();
		let inbound_static_public_key = PublicKey::from_secret_key(&curve, &inbound_static_private_key);

		Transport::<PeerHandshakeImpl>::new_outbound(&outbound_static_private_key, &inbound_static_public_key, &outbound_ephemeral_private_key)
	}

	fn create_inbound_for_test<PeerHandshakeImpl: IPeerHandshake>() -> Transport<PeerHandshakeImpl> {
		let inbound_static_private_key = SecretKey::from_slice(&[0x_21_u8; 32]).unwrap();
		let inbound_ephemeral_private_key = SecretKey::from_slice(&[0x_22_u8; 32]).unwrap();

		Transport::<PeerHandshakeImpl>::new_inbound(&inbound_static_private_key, &inbound_ephemeral_private_key)
	}

	// Test initial states start off unconnected
	#[test]
	fn inbound_unconnected() {
		let transport = create_inbound_for_test::<PeerHandshakeTestStubFail>();

		assert!(!transport.is_connected());
	}

	#[test]
	fn outbound_unconnected() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubFail>();
		transport.set_up_outbound();

		assert!(!transport.is_connected());
	}

	// Test that errors in the handshake code are reraised through the transport
	#[test]
	fn inbound_handshake_error_reraises() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubFail>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy).err(), Some("Oh no!".to_string()));
	}

	#[test]
	fn outbound_handshake_error_reraises() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubFail>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy).err(), Some("Oh no!".to_string()));
	}

	#[test]
	fn inbound_handshake_data_goes_to_queue() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubBytes>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(false));
		assert!(!transport.is_connected());

		assert_matches!(&spy[..], [_]);
	}

	// Test that data returned from the in-progress handshake code makes it through to the outbound buffer
	#[test]
	fn outbound_handshake_data_goes_to_queue() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubBytes>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(false));
		assert!(!transport.is_connected());

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn inbound_handshake_complete_ready_for_encryption() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(true));
		assert!(transport.is_connected());
	}

	// Test get_their_node_id() in unconnected and connected scenarios
	#[test]
	#[should_panic(expected = "Retrieving the remote node_id is only supported after transport is connected")]
	fn inbound_unconnected_get_their_node_id_panics() {
		let transport = create_inbound_for_test::<PeerHandshakeTestStubFail>();

		let _should_panic = transport.get_their_node_id();
	}

	#[test]
	#[should_panic(expected = "Retrieving the remote node_id is only supported after transport is connected")]
	fn outbound_unconnected_get_their_node_id_panics() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubFail>();
		transport.set_up_outbound();

		let _should_panic = transport.get_their_node_id();
	}

	#[test]
	fn inbound_unconnected_get_their_node_id() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(true));
		let _no_panic = transport.get_their_node_id();
	}

	#[test]
	fn outbound_unconnected_get_their_node_id() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(true));
		let _no_panic = transport.get_their_node_id();
	}

	// Test that when a handshake completes is_connected() is correct
	#[test]
	fn outbound_handshake_complete_ready_for_encryption() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(true));
		assert!(transport.is_connected());
		let _no_panic = transport.get_their_node_id();
	}

	#[test]
	#[should_panic(expected = "Enqueueing messages only supported after transport is connected")]
	fn inbound_enqueue_message_panic() {
		let logger = TestLogger::new();
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);
	}

	// Test that enqueue_message() panics in the wrong state
	#[test]
	#[should_panic(expected = "Enqueueing messages only supported after transport is connected")]
	fn outbound_enqueue_message_panic() {
		let logger = TestLogger::new();
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);
	}

	// Test that enqueue_message() puts something into the outbound buffer
	#[test]
	fn inbound_enqueue_message_encrypts() {
		let logger = TestLogger::new();
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(true));

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn outbound_enqueue_message_encrypts() {
		let logger = TestLogger::new();
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy), Ok(true));

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn inbound_not_connected_empty() {
		let logger = TestLogger::new();
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();

		let messages = transport.drain_messages(&logger).unwrap();
		assert_eq!(messages.len(), 0);
	}

	#[test]
	fn outbound_not_connected_empty() {
		let logger = TestLogger::new();
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();

		let messages = transport.drain_messages(&logger).unwrap();
		assert_eq!(messages.len(), 0);
	}
}