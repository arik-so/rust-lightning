//! " The logic to monitor for on-chain transactions and create the relevant claim responses lives"
//! " here."
//! ""
//! " ChannelMonitor objects are generated by ChannelManager in response to relevant"
//! " messages/actions, and MUST be persisted to disk (and, preferably, remotely) before progress can"
//! " be made in responding to certain messages, see ManyChannelMonitor for more."
//! ""
//! " Note that ChannelMonitors are an important part of the lightning trust model and a copy of the"
//! " latest ChannelMonitor must always be actively monitoring for chain updates (and no out-of-date"
//! " ChannelMonitors should do so). Thus, if you're building rust-lightning into an HSM or other"
//! " security-domain-separated system design, you should consider having multiple paths for"
//! " ChannelMonitors to get out of the HSM and onto monitoring devices."

use std::ffi::c_void;
use bitcoin::hashes::Hash;

use bitcoin::blockdata::block::BlockHeader as lnBlockHeader;
use bitcoin::blockdata::transaction::TxOut as lnTxOut;
use bitcoin::blockdata::transaction::Transaction as lnTransaction;
use bitcoin::blockdata::script::Script as lnScript;
use bitcoin::blockdata::script::Builder as lnBuilder;
use bitcoin::blockdata::opcodes as lnopcodes;
use bitcoin::consensus::encode as lnencode;
use bitcoin::util::hash::BitcoinHash as lnBitcoinHash;
use bitcoin::hashes::Hash as lnHash;
use bitcoin::hash_types::Txid as lnTxid;
use bitcoin::hash_types::BlockHash as lnBlockHash;
use bitcoin::hash_types::WPubkeyHash as lnWPubkeyHash;
use bitcoin::secp256k1::Secp256k1 as lnSecp256k1;
use bitcoin::secp256k1::Signature as lnSignature;
use bitcoin::secp256k1::key::SecretKey as lnSecretKey;
use bitcoin::secp256k1::key::PublicKey as lnPublicKey;
use bitcoin::secp256k1 as lnsecp256k1;

use lightning::ln::channelmonitor::ChannelMonitorUpdate as lnChannelMonitorUpdateImport;
type lnChannelMonitorUpdate = lnChannelMonitorUpdateImport;

/// " An update generated by the underlying Channel itself which contains some new information the"
/// " ChannelMonitor should be made aware of."
#[repr(C)]
pub struct ChannelMonitorUpdate {
	pub(crate) inner: *const lnChannelMonitorUpdate,
}

#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_free(this_ptr: ChannelMonitorUpdate) {
	let _ = unsafe { Box::from_raw(this_ptr.inner as *mut lnChannelMonitorUpdate) };
}
/// " The sequence number of this update. Updates *must* be replayed in-order according to this"
/// " sequence number (and updates may panic if they are not). The update_id values are strictly"
/// " increasing and increase by one for each new update."
/// ""
/// " This sequence number is also used to track up to which points updates which returned"
/// " ChannelMonitorUpdateErr::TemporaryFailure have been applied to all copies of a given"
/// " ChannelMonitor when ChannelManager::channel_monitor_updated is called."
#[no_mangle]
pub extern "C" fn ChannelMonitorUpdate_set_update_id(this_ptr: &mut ChannelMonitorUpdate, val: u64) {
	unsafe { &mut *(this_ptr.inner as *mut lnChannelMonitorUpdate) }.update_id = val;
}
/// " An error enum representing a failure to persist a channel monitor update."
#[repr(C)]
pub enum ChannelMonitorUpdateErr {
	/// " Used to indicate a temporary failure (eg connection to a watchtower or remote backup of"
	/// " our state failed, but is expected to succeed at some point in the future)."
	/// ""
	/// " Such a failure will \"freeze\" a channel, preventing us from revoking old states or"
	/// " submitting new commitment transactions to the remote party. Once the update(s) which failed"
	/// " have been successfully applied, ChannelManager::channel_monitor_updated can be used to"
	/// " restore the channel to an operational state."
	/// ""
	/// " Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If"
	/// " you return a TemporaryFailure you must ensure that it is written to disk safely before"
	/// " writing out the latest ChannelManager state."
	/// ""
	/// " Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur"
	/// " (eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting"
	/// " to claim it on this channel) and those updates must be applied wherever they can be. At"
	/// " least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should"
	/// " be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to"
	/// " the channel which would invalidate previous ChannelMonitors are not made when a channel has"
	/// " been \"frozen\"."
	/// ""
	/// " Note that even if updates made after TemporaryFailure succeed you must still call"
	/// " channel_monitor_updated to ensure you have the latest monitor and re-enable normal channel"
	/// " operation."
	/// ""
	/// " Note that the update being processed here will not be replayed for you when you call"
	/// " ChannelManager::channel_monitor_updated, so you must store the update itself along"
	/// " with the persisted ChannelMonitor on your own local disk prior to returning a"
	/// " TemporaryFailure. You may, of course, employ a journaling approach, storing only the"
	/// " ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at"
	/// " reload-time."
	/// ""
	/// " For deployments where a copy of ChannelMonitors and other local state are backed up in a"
	/// " remote location (with local copies persisted immediately), it is anticipated that all"
	/// " updates will return TemporaryFailure until the remote copies could be updated."
	TemporaryFailure,
	/// " Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a"
	/// " different watchtower and cannot update with all watchtowers that were previously informed"
	/// " of this channel). This will force-close the channel in question (which will generate one"
	/// " final ChannelMonitorUpdate which must be delivered to at least one ChannelMonitor copy)."
	/// ""
	/// " Should also be used to indicate a failure to update the local persisted copy of the channel"
	/// " monitor."
	PermanentFailure,
}
use lightning::ln::channelmonitor::ChannelMonitorUpdateErr as lnChannelMonitorUpdateErr;
impl ChannelMonitorUpdateErr {
	#[allow(unused)]
	pub(crate) fn to_ln(&self) -> lnChannelMonitorUpdateErr {
		match self {
			ChannelMonitorUpdateErr::TemporaryFailure => lnChannelMonitorUpdateErr::TemporaryFailure,
			ChannelMonitorUpdateErr::PermanentFailure => lnChannelMonitorUpdateErr::PermanentFailure,
		}
	}
	#[allow(unused)]
	pub(crate) fn from_ln(lnt: lnChannelMonitorUpdateErr) -> Self {
		match lnt {
			lnChannelMonitorUpdateErr::TemporaryFailure => ChannelMonitorUpdateErr::TemporaryFailure,
			lnChannelMonitorUpdateErr::PermanentFailure => ChannelMonitorUpdateErr::PermanentFailure,
		}
	}
}

use lightning::ln::channelmonitor::MonitorUpdateError as lnMonitorUpdateErrorImport;
type lnMonitorUpdateError = lnMonitorUpdateErrorImport;

/// " General Err type for ChannelMonitor actions. Generally, this implies that the data provided is"
/// " inconsistent with the ChannelMonitor being called. eg for ChannelMonitor::update_monitor this"
/// " means you tried to update a monitor for a different channel or the ChannelMonitorUpdate was"
/// " corrupted."
/// " Contains a human-readable error message."
#[repr(C)]
pub struct MonitorUpdateError {
	pub(crate) inner: *const lnMonitorUpdateError,
}

#[no_mangle]
pub extern "C" fn MonitorUpdateError_free(this_ptr: MonitorUpdateError) {
	let _ = unsafe { Box::from_raw(this_ptr.inner as *mut lnMonitorUpdateError) };
}

use lightning::ln::channelmonitor::HTLCUpdate as lnHTLCUpdateImport;
type lnHTLCUpdate = lnHTLCUpdateImport;

/// " Simple structure send back by ManyChannelMonitor in case of HTLC detected onchain from a"
/// " forward channel and from which info are needed to update HTLC in a backward channel."
#[repr(C)]
pub struct HTLCUpdate {
	pub(crate) inner: *const lnHTLCUpdate,
}

#[no_mangle]
pub extern "C" fn HTLCUpdate_free(this_ptr: HTLCUpdate) {
	let _ = unsafe { Box::from_raw(this_ptr.inner as *mut lnHTLCUpdate) };
}

use lightning::ln::channelmonitor::ChannelMonitor as lnChannelMonitorImport;
type lnChannelMonitor = lnChannelMonitorImport<crate::chain::keysinterface::ChannelKeys>;

/// " A ChannelMonitor handles chain events (blocks connected and disconnected) and generates"
/// " on-chain transactions to ensure no loss of funds occurs."
/// ""
/// " You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date"
/// " information and are actively monitoring the chain."
/// ""
/// " Pending Events or updated HTLCs which have not yet been read out by"
/// " get_and_clear_pending_htlcs_updated or get_and_clear_pending_events are serialized to disk and"
/// " reloaded at deserialize-time. Thus, you must ensure that, when handling events, all events"
/// " gotten are fully handled before re-serializing the new state."
#[repr(C)]
pub struct ChannelMonitor {
	pub(crate) inner: *const lnChannelMonitor,
}

#[no_mangle]
pub extern "C" fn ChannelMonitor_free(this_ptr: ChannelMonitor) {
	let _ = unsafe { Box::from_raw(this_ptr.inner as *mut lnChannelMonitor) };
}
/// " Simple trait indicating ability to track a set of ChannelMonitors and multiplex events between"
/// " them. Generally should be implemented by keeping a local SimpleManyChannelMonitor and passing"
/// " events to it, while also taking any add/update_monitor events and passing them to some remote"
/// " server(s)."
/// ""
/// " In general, you must always have at least one local copy in memory, which must never fail to"
/// " update (as it is responsible for broadcasting the latest state in case the channel is closed),"
/// " and then persist it to various on-disk locations. If, for some reason, the in-memory copy fails"
/// " to update (eg out-of-memory or some other condition), you must immediately shut down without"
/// " taking any further action such as writing the current state to disk. This should likely be"
/// " accomplished via panic!() or abort()."
/// ""
/// " Note that any updates to a channel's monitor *must* be applied to each instance of the"
/// " channel's monitor everywhere (including remote watchtowers) *before* this function returns. If"
/// " an update occurs and a remote watchtower is left with old state, it may broadcast transactions"
/// " which we have revoked, allowing our counterparty to claim all funds in the channel!"
/// ""
/// " User needs to notify implementors of ManyChannelMonitor when a new block is connected or"
/// " disconnected using their `block_connected` and `block_disconnected` methods. However, rather"
/// " than calling these methods directly, the user should register implementors as listeners to the"
/// " BlockNotifier and call the BlockNotifier's `block_(dis)connected` methods, which will notify"
/// " all registered listeners in one go."
#[repr(C)]
pub struct ManyChannelMonitor {
	pub this_arg: *mut c_void,
	//XXX: Need to export add_monitor
	//XXX: Need to export update_monitor
	//XXX: Need to export get_and_clear_pending_htlcs_updated
}
unsafe impl Send for ManyChannelMonitor {}
unsafe impl Sync for ManyChannelMonitor {}

use lightning::ln::channelmonitor::ManyChannelMonitor as lnManyChannelMonitor;
impl lnManyChannelMonitor for ManyChannelMonitor {
	type Keys = crate::chain::keysinterface::ChannelKeys;
	fn add_monitor(&self, funding_txo: lightning::chain::transaction::OutPoint, monitor: lightning::ln::channelmonitor::ChannelMonitor<Self::Keys>) -> Result<(), lightning::ln::channelmonitor::ChannelMonitorUpdateErr> {
		unimplemented!();
	}
	fn update_monitor(&self, funding_txo: lightning::chain::transaction::OutPoint, monitor: lightning::ln::channelmonitor::ChannelMonitorUpdate) -> Result<(), lightning::ln::channelmonitor::ChannelMonitorUpdateErr> {
		unimplemented!();
	}
	fn get_and_clear_pending_htlcs_updated(&self) -> Vec<lightning::ln::channelmonitor::HTLCUpdate> {
		unimplemented!();
	}
}

// We're essentially a pointer already, or at least a set of pointers, so allow us to be used
// directly as a Deref trait in higher-level structs:
impl std::ops::Deref for ManyChannelMonitor {
	type Target = Self;
	fn deref(&self) -> &Self {
		self
	}
}
/// " Gets the update_id from the latest ChannelMonitorUpdate which was applied to this"
/// " ChannelMonitor."
#[no_mangle]
pub extern "C" fn ChannelMonitor_get_latest_update_id(this_arg: &ChannelMonitor) -> u64 {
	unsafe { &*this_arg.inner }.get_latest_update_id()
}

